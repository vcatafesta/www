/* eslint import/no-extraneous-dependencies: ["error", {"peerDependencies": true}] */
/* eslint-disable import/no-dynamic-require */
/* eslint-disable global-require */
// Ensure environment variables are read.
require('./env');

const fs = require('fs');
const chalk = require('chalk');
const webpack = require('webpack');
const WebpackDevServer = require('webpack-dev-server');
const clearConsole = require('react-dev-utils/clearConsole');
const checkRequiredFiles = require('react-dev-utils/checkRequiredFiles');
const {
  createCompiler,
  prepareProxy,
  prepareUrls,
} = require('react-dev-utils/WebpackDevServerUtils');
const openBrowser = require('react-dev-utils/openBrowser');

const cwd = process.cwd();
const paths = require(`${cwd}/config/paths`);
const config = require(`${cwd}/config/webpack.config`);
const createDevServerConfig = require(`${cwd}/config/webpackDevServer.config`);

// Makes the script crash on unhandled rejections instead of silently
// ignoring them. In the future, promise rejections that are not handled will
// terminate the Node.js process with a non-zero exit code.
process.on('unhandledRejection', (err) => {
  throw err;
});

process.env.NODE_ENV = 'development';

const useYarn = fs.existsSync(paths.yarnLockFile);
const isInteractive = process.stdout.isTTY;

// Warn and crash if required files are missing
if (!checkRequiredFiles([paths.template, paths.appModule])) {
  process.exit(1);
}

module.exports = function serve(requestedPort) {
  // We attempt to use the default port but if it is busy, we offer the user to
  // run on a different port. `detect()` Promise resolves to the next free port.

  // Tools like Cloud9 rely on this.
  const port = parseInt(process.env.PORT, 10) || requestedPort || 3000;
  const HOST = process.env.HOST || '0.0.0.0';

  if (port == null) {
    return;
  }
  const protocol = process.env.HTTPS === 'true' ? 'https' : 'http';
  const appName = require(paths.packageJson).name;
  const urls = prepareUrls(protocol, HOST, port);
  // Create a webpack compiler that is configured with custom messages.
  const compiler = createCompiler(webpack, config, appName, urls, useYarn);
  // Load proxy config
  const proxySetting = require(paths.packageJson).proxy;
  const proxyConfig = prepareProxy(proxySetting, paths.appPublic);
  // Serve webpack assets generated by the compiler over a web sever.
  const serverConfig = createDevServerConfig(proxyConfig, urls.lanUrlForConfig);
  const devServer = new WebpackDevServer(compiler, serverConfig);
  // Launch WebpackDevServer.
  devServer.listen(port, HOST, (err) => {
    if (err) {
      console.log(err);
      return;
    }
    if (isInteractive) {
      clearConsole();
    }
    console.log(chalk.cyan('Starting the development server...\n'));
    openBrowser(urls.localUrlForBrowser);
  });

  ['SIGINT', 'SIGTERM'].forEach((sig) => {
    process.on(sig, () => {
      devServer.close();
      process.exit();
    });
  });
};
